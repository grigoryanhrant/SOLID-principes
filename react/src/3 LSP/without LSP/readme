Возьмем ModalHolder компонент. Этот компонент принимает contentToShow в качестве реквизита
и показывает его внутри модального окна: Проблема в том, что теперь нет ограничений на то,
что можно передать в ModalHolder компонент. Через переменную сюда можно передать абсолютно
все что угодно contentToShow. Во-первых, давайте проверим, работает ли наш код и все ли идет как положено:
Теперь, если вы откроете модальное окно, оно будет работать нормально и покажет вам модальное окно:
Давайте воспользуемся недостатком, который мы описали ранее, и посмотрим, как он может уничтожить наше приложение.
Давайте попробуем передать объект в ModalHolder и посмотрим, что произойдет:
Этот код совершенно исправен и не выдаст ошибки компиляции. Теперь давайте откроем наше приложение и посмотрим,
что произойдет, если мы нажмем на кнопку:

Таким образом, наше приложение падает, хотя в нашем коде нет ошибок. Что здесь пошло не так?
Наш Modal компонент может содержать другой компонент React. Но другие компоненты не обязаны
следовать этому, потому что нет контракта.

Какое решение?
Теперь мы увидим важность использования TypeScript в нашем приложении и почему это важно.
Давайте рефакторим наш ModalHolderкомпонент на TypeScript и посмотрим, что получится:
Итак, теперь мы реорганизовали наш компонент, чтобы он принимал свойство contentToShowтолько
тогда, когда он получает файл JSX.Element. Если кто-то захочет передать для рендеринга что-то,
что не является допустимым компонентом, мы получим сообщение об ошибке:
Вуаля! Теперь все другие компоненты, которые хотят подключиться к ModalHolderкомпоненту,
должны следовать контракту, чтобы не создавать неожиданного поведения.

Мы сделали это?
Мы разработали наш ModalHolderкомпонент таким образом, что ни один дочерний компонент,
использующий этот компонент, не может создать неожиданное поведение, потому что они должны соблюдать правила,
установленные родителем. Это именно то, что касается принципа замещения Лискова.
Так что да, мы сделали это!
