Возьмем очень распространенный вариант использования. Мы собираемся сделать вызов API из нашего компонента вполучить
некоторые данные из удаленного источника. Посмотрите на этот компонент. Это зависит от некоторых удаленных данных,
которые извлекаются прямо из компонента. Основная обязанность нашего Users компонента визуализировать данные.
Он не должен заботиться о том, как извлекаются данные или откуда они поступают. Этот компонент слишком много знает
и это проблема. Допустим, у вас есть десять других компонентов, и все они получают свои собственные данные.
Теперь приходит ваш менеджер и говорит вам использовать axios вместо fetch. У тебя проблемы! Теперь вам нужно зайти
в каждый файл и реорганизовать логику для использования axios. Но жизнь не так проста! Через несколько дней снова
приходит ваш менеджер и говорит вам внедрить кеширование. Вы должны сделать то же самое еще раз.
Таким образом, это увеличивает вероятность появления ошибки в вашем программном обеспечении. Кроме того, код
становится неподдерживаемым, и драгоценное время тратится впустую. Давайте введем хук для извлечения данных и
абстрагируем нашу логику за пределами нашего компонента, потому что это именно то, что говорит нам этот принцип.
Зависеть от абстракции, помните? Теперь используйте этот хук внутри нашего Users компонента:
Обратите внимание на замечательную вещь в этом решении: ваш useFetch хук не заботится о том, кто его вызывает.
Он просто принимает URLв качестве входных данных и возвращает данные. Теперь все остальные компоненты могут
использовать хук, который мы только что написали. И наш Users компонент больше не зависит от конкретных деталей того,
как возвращаются данные или какая библиотека используется! В большинстве случаев, если вы нарушаете принцип
единственной ответственности, вы также можете нарушать принцип инверсии зависимостей.
