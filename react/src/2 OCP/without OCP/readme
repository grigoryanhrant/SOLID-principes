Скажем, у нас есть User компонент, которому мы передаем данные пользователя, и основная цель этого класса
показать сведения об этом конкретном пользователе. Это достаточно просто для начала. Но наша жизнь не так проста.
Через несколько дней наш менеджер сообщает нам, что в нашей системе есть три типа пользователей: SuperAdmin, Admin, и т.д.
И каждый из них будет иметь разную информацию и функциональные возможности.
Ну, первое и очевидное решение состоит в том, чтобы иметь условное выражение внутри нашего компонента и отображать
различную информацию в зависимости от разных типов пользователей.

Во первых, наш код теперь беспорядочный.

Во-вторых, что, если нам нужен другой тип пользователя? Затем нам нужно будет User.js добавить еще одно условие для
этого конкретного типа пользователя. Это явное нарушение принципа Open-Closed, потому что нам не разрешено изменять
код внутри User компонента.

Итак, есть два основных метода, которые мы можем применить в этом сценарии:

Компонент высшего порядка
Компонентный состав

По возможности лучше идти по второму пути, но могут быть случаи, когда использование HOC необходимо.
Сейчас мы будем использовать технику, рекомендованную Facebook, которая называется композицией компонентов.

Давайте создадим отдельные пользовательские компоненты
Теперь нам нужно спроектировать наш код таким образом, чтобы нам не нужно было добавлять условное выражение внутри\
User.js компонента.

Создадим отдельный компонент для SuperAdmin:
Аналогично, еще один для Admin пользователей:

Теперь мы можем создать столько типов пользователей, сколько нам нужно. Наша логика для конкретных пользователей
инкапсулирована, и нам не нужно пересматривать наш код для каких-либо дополнительных модификаций.

Кто-то может возразить, что мы без необходимости увеличиваем количество файлов.
Конечно, вы можете пока оставить все как есть, но вы определенно почувствуете трудности по мере роста сложности приложения
